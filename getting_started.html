

<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">


<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    
    <title>Getting started &mdash; nested sampling 1.0.0 documentation</title>
    
    <link rel="stylesheet" href="_static/scipy.css" type="text/css" />
    <link rel="stylesheet" href="_static/pygments.css" type="text/css" />
    
    <script type="text/javascript">
      var DOCUMENTATION_OPTIONS = {
        URL_ROOT:    '',
        VERSION:     '1.0.0',
        COLLAPSE_INDEX: false,
        FILE_SUFFIX: '.html',
        HAS_SOURCE:  false
      };
    </script>
    <script type="text/javascript" src="_static/jquery.js"></script>
    <script type="text/javascript" src="_static/underscore.js"></script>
    <script type="text/javascript" src="_static/doctools.js"></script>
    <script type="text/javascript" src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
    <link rel="top" title="nested sampling 1.0.0 documentation" href="index.html" />
    <link rel="next" title="Nested Sampling" href="NestedSampling.html" />
    <link rel="prev" title="nested sampling : the Python parallel nested sampling algorithm" href="index.html" /> 
  </head>
  <body>
    <div class="related">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="genindex.html" title="General Index"
             accesskey="I">index</a></li>
        <li class="right" >
          <a href="py-modindex.html" title="Python Module Index"
             >modules</a> |</li>
        <li class="right" >
          <a href="NestedSampling.html" title="Nested Sampling"
             accesskey="N">next</a> |</li>
        <li class="right" >
          <a href="index.html" title="nested sampling : the Python parallel nested sampling algorithm"
             accesskey="P">previous</a> |</li>
        <li><a href="index.html">nested sampling 1.0.0 documentation</a> &raquo;</li> 
      </ul>
    </div>  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body">
            
  <div class="section" id="getting-started">
<h1>Getting started<a class="headerlink" href="#getting-started" title="Permalink to this headline">¶</a></h1>
<div class="section" id="basic-elements">
<h2>Basic elements<a class="headerlink" href="#basic-elements" title="Permalink to this headline">¶</a></h2>
<p>Nested sampling consists of three main elements:</p>
<ol class="arabic simple">
<li>the <tt class="xref py py-class docutils literal"><span class="pre">NestedSampling</span></tt> class,</li>
<li>the <tt class="xref py py-class docutils literal"><span class="pre">MonteCarloWalker</span></tt> class and</li>
<li>the <tt class="xref py py-func docutils literal"><span class="pre">run_nested_sampling()</span></tt> method.</li>
</ol>
<p>The <tt class="xref py py-class docutils literal"><span class="pre">NestedSampling</span></tt> class fundamentally requires only three input parameters:</p>
<ol class="arabic simple">
<li>a list of initial samples, which we refer to as <tt class="docutils literal"><span class="pre">replicas</span></tt></li>
<li>a callable of type <tt class="xref py py-class docutils literal"><span class="pre">MonteCarloWalker</span></tt> and</li>
<li>the number of cores on which to run the simulation.</li>
</ol>
<p>Other optional arguments can be useful but we shall ignore them for the time being. The <tt class="xref py py-class docutils literal"><span class="pre">MonteCarloWalker</span></tt>
takes care of walking the replicas under some energy (log-likelihood) constraint, to perform uniform sampling
(rejection sampling) in phase space. <tt class="xref py py-class docutils literal"><span class="pre">MonteCarloWalker</span></tt> takes as parameters:</p>
<ol class="arabic simple">
<li>a <tt class="docutils literal"><span class="pre">potential</span></tt>, which is a class that through a <tt class="docutils literal"><span class="pre">get_energy()</span></tt> function,
returns an energy for a given a set of coordinates.</li>
<li>a <tt class="docutils literal"><span class="pre">takestep</span></tt> method which is some callable that takes a set of coordinates and a step-size,
displaces them (takes a step) and returns the coordinates, see for instance <tt class="xref py py-func docutils literal"><span class="pre">random_displace()</span></tt>.</li>
<li>a list of accept_tests, which are additional configurational tests. For instance
one might want the walkers to stay within a certain spherical container, as well as obeying the energy constraint.</li>
<li>one can optionally pass to the <tt class="xref py py-class docutils literal"><span class="pre">MonteCarloWalker</span></tt> a list of <em>events</em> which is a set of operations
that one want to do on the new configuration.</li>
</ol>
<p>Integration with the <a class="reference external" href="https://pele-python.github.io/mcpele/">MCpele</a> walkers is possible
(they provide c++ performance through a Python interface!), but this will be addressed in another tutorial.
The <tt class="xref py py-func docutils literal"><span class="pre">run_nested_sampling()</span></tt> method primarily takes as parameters:</p>
<ol class="arabic simple">
<li>an object of type <tt class="xref py py-class docutils literal"><span class="pre">NestedSampling</span></tt></li>
<li>a string to label the output</li>
<li>a tolerance for the termination of the Nested Sampling iteration. By deafault we terminate the
run when the difference in energy between the highest and lowest energy replicas is less than etol</li>
<li>the maximum number of iterations</li>
</ol>
</div>
<div class="section" id="writing-a-nested-sampling-runner">
<h2>Writing a nested sampling runner<a class="headerlink" href="#writing-a-nested-sampling-runner" title="Permalink to this headline">¶</a></h2>
<p>Here we shall cover the basic steps necessary for the implementation of a nested sampling runner to
perform our calculations. In the example/harmonic folder we provide two basic implementation of a
nested sampling runner with thread based parallelisation (single node) and distributed parallelisation (multiple nodes).
Let us start with the most simple case.</p>
<p>First of all we need to import the modules that we need:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="kn">from</span> <span class="nn">nested_sampling</span> <span class="kn">import</span> <span class="n">NestedSampling</span><span class="p">,</span> <span class="n">MonteCarloWalker</span><span class="p">,</span> <span class="n">Harmonic</span><span class="p">,</span> <span class="n">run_nested_sampling</span><span class="p">,</span> <span class="n">Replica</span>
</pre></div>
</div>
<p>and choose a reasonable set of parameters (note that in the actual example we use the <tt class="docutils literal"><span class="pre">argparse</span></tt> module instead):</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">ndof</span> <span class="o">=</span> <span class="mi">3</span>        <span class="c">#no. of degrees of freedom</span>
<span class="n">nproc</span> <span class="o">=</span> <span class="mi">4</span>       <span class="c">#no. of cores</span>
<span class="n">nsteps</span> <span class="o">=</span> <span class="mf">1e3</span>    <span class="c">#no. of Monte Carlo steps per walk</span>
<span class="n">nreplicas</span> <span class="o">=</span> <span class="mf">1e3</span> <span class="c">#no. of initial samples (replicas)</span>
<span class="n">stepsize</span> <span class="o">=</span> <span class="mf">0.1</span>  <span class="c">#stepsize</span>
<span class="n">etol</span> <span class="o">=</span> <span class="mf">0.01</span>     <span class="c">#stepsize</span>
</pre></div>
</div>
<p>For the potential we choose the most simple function form, that is a <tt class="docutils literal"><span class="pre">ndof</span></tt> dimensional harmonic well,
which we take from the models modules. As we mentioned before each potential needs to have a
<tt class="docutils literal"><span class="pre">get_energy</span></tt> function that returns the energy for a given set of coordinates:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="kn">from</span> <span class="nn">nested_sampling.utils.rotations</span> <span class="kn">import</span> <span class="n">vector_random_uniform_hypersphere</span>

<span class="k">class</span> <span class="nc">Harmonic</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>
    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">ndof</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">ndim</span> <span class="o">=</span> <span class="n">ndof</span>

    <span class="k">def</span> <span class="nf">get_energy</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">x</span><span class="p">):</span>
        <span class="k">assert</span> <span class="nb">len</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="o">==</span> <span class="bp">self</span><span class="o">.</span><span class="n">ndof</span>
        <span class="k">return</span> <span class="mf">0.5</span> <span class="o">*</span> <span class="n">x</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">get_random_configuration</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">radius</span><span class="o">=</span><span class="mf">10.</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; return a random vector sampled uniformly from within a hypersphere of dimensions self.ndim&quot;&quot;&quot;</span>
        <span class="n">x</span> <span class="o">=</span> <span class="n">vector_random_uniform_hypersphere</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">ndof</span><span class="p">)</span> <span class="o">*</span> <span class="n">radius</span>
        <span class="k">return</span> <span class="n">x</span>
</pre></div>
</div>
<p>Now that we have a potential, we need to construct a potential object and the Monte Carlo runner:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="c">#construct potential (cost function)</span>
<span class="n">potential</span> <span class="o">=</span> <span class="n">Harmonic</span><span class="p">(</span><span class="n">ndof</span><span class="p">)</span>

<span class="c">#construct Monte Carlo walker</span>
<span class="n">mc_runner</span> <span class="o">=</span> <span class="n">MonteCarloWalker</span><span class="p">(</span><span class="n">potential</span><span class="p">,</span> <span class="n">mciter</span><span class="o">=</span><span class="n">nsteps</span><span class="p">)</span>
</pre></div>
</div>
<p>We the need to initialise the <tt class="docutils literal"><span class="pre">nreplicas</span></tt> samples, we do so by uniformly sampling a set of configurations,
and construct the <tt class="xref py py-class docutils literal"><span class="pre">NestedSampling</span></tt> class object:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="c">#initialise replicas (initial uniformly samples set of configurations)</span>
<span class="n">replicas</span> <span class="o">=</span> <span class="p">[]</span>
<span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="nb">xrange</span><span class="p">(</span><span class="n">nreplicas</span><span class="p">):</span>
    <span class="n">x</span> <span class="o">=</span> <span class="n">potential</span><span class="o">.</span><span class="n">get_random_configuration</span><span class="p">()</span>
    <span class="n">replicas</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">Replica</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">potential</span><span class="o">.</span><span class="n">get_energy</span><span class="p">(</span><span class="n">x</span><span class="p">)))</span>

<span class="c">#construct Nested Sampling object</span>
<span class="n">ns</span> <span class="o">=</span> <span class="n">NestedSampling</span><span class="p">(</span><span class="n">replicas</span><span class="p">,</span> <span class="n">mc_runner</span><span class="p">,</span> <span class="n">stepsize</span><span class="o">=</span><span class="n">stepsize</span><span class="p">,</span> <span class="n">nproc</span><span class="o">=</span><span class="n">nproc</span><span class="p">,</span> <span class="n">max_stepsize</span><span class="o">=</span><span class="mi">10</span><span class="p">)</span>
</pre></div>
</div>
<p>Finally we can run nested sampling doing:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">run_nested_sampling</span><span class="p">(</span><span class="n">ns</span><span class="p">,</span> <span class="n">label</span><span class="o">=</span><span class="s">&quot;run_hparticle&quot;</span><span class="p">,</span> <span class="n">etol</span><span class="o">=</span><span class="n">etol</span><span class="p">)</span>
</pre></div>
</div>
<p>which will perform nested sampling on <tt class="docutils literal"><span class="pre">nproc</span></tt> cores, on a simple node and with output:</p>
<ul class="simple">
<li>label.energies (one for each iteration)</li>
<li>label.replicas_final (live replica energies when NS terminates)</li>
</ul>
<div class="section" id="running-nested-sampling-on-a-single-node">
<h3>Running nested sampling on a single node<a class="headerlink" href="#running-nested-sampling-on-a-single-node" title="Permalink to this headline">¶</a></h3>
<p>In practice if one were to run the example provided, which makes use of <tt class="docutils literal"><span class="pre">argparse</span></tt>, he would have
to use the following terminal command-line:</p>
<div class="highlight-python"><pre>$python examples/harmonic/run_hparticle.py --nreplicas 1e3 --ndof 3 --nprocs 4 --nsteps 1e3 --stepsize 0.1 --etol 0.01</pre>
</div>
</div>
</div>
<div class="section" id="writing-a-nested-sampling-runner-for-distributed-computing">
<h2>Writing a nested sampling runner for distributed computing<a class="headerlink" href="#writing-a-nested-sampling-runner-for-distributed-computing" title="Permalink to this headline">¶</a></h2>
<p>The nested sampling package allows to run the algorithm on distributed architectures making use of
the <a class="reference external" href="https://pythonhosted.org/Pyro4/">Pyro4</a> library. First of all we need to install Pyro4 and
add the environment variable:</p>
<div class="highlight-python"><pre>$export PYRO_SERIALIZERS_ACCEPTED=serpent,json,marshal,pickle</pre>
</div>
<p>or add it to the .bashrc file if we intend to use it frequently. This parallelisation makes use of a
<strong>dispatcher</strong> (the middle man) that takes care of dispatching the jobs to the <strong>workers</strong>
assigned to it by the <tt class="xref py py-func docutils literal"><span class="pre">run_nested_sampling()</span></tt> function. Workers are very similar to the
nested sampling runners above.</p>
<p>The nested sampling runner needs only to be aware of the location of the dispatcher, hence we
can easily modify the above method by adding:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="c">#try to read dispatecher URI from default file location</span>
<span class="n">dispatcherURI</span> <span class="o">=</span> <span class="bp">True</span>       <span class="c">#if true expects dispatcher location</span>
<span class="n">dispatcherURI_file</span> <span class="o">=</span> <span class="bp">None</span>  <span class="c">#when None use default filename</span>

<span class="k">if</span> <span class="n">dispatcherURI</span> <span class="ow">is</span> <span class="bp">True</span><span class="p">:</span>
    <span class="k">with</span> <span class="nb">open</span> <span class="p">(</span><span class="s">&quot;dispatcher_uri.dat&quot;</span><span class="p">,</span> <span class="s">&quot;r&quot;</span><span class="p">)</span> <span class="k">as</span> <span class="n">rfile</span><span class="p">:</span>
        <span class="n">dispatcherURI</span> <span class="o">=</span> <span class="n">rfile</span><span class="o">.</span><span class="n">read</span><span class="p">()</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span><span class="s">&#39;</span><span class="se">\n</span><span class="s">&#39;</span><span class="p">,</span> <span class="s">&#39;&#39;</span><span class="p">)</span>
<span class="k">elif</span> <span class="n">dispatcherURI_file</span> <span class="o">!=</span> <span class="bp">None</span><span class="p">:</span>
    <span class="k">with</span> <span class="nb">open</span> <span class="p">(</span><span class="n">args</span><span class="o">.</span><span class="n">dispatcherURI_file</span><span class="p">,</span> <span class="s">&quot;r&quot;</span><span class="p">)</span> <span class="k">as</span> <span class="n">rfile</span><span class="p">:</span>
        <span class="n">dispatcherURI</span> <span class="o">=</span> <span class="n">rfile</span><span class="o">.</span><span class="n">read</span><span class="p">()</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span><span class="s">&#39;</span><span class="se">\n</span><span class="s">&#39;</span><span class="p">,</span> <span class="s">&#39;&#39;</span><span class="p">)</span>
<span class="k">else</span><span class="p">:</span>
    <span class="n">dispatcherURI</span> <span class="o">=</span> <span class="bp">None</span>
</pre></div>
</div>
<p>where we prescribe to read the address of the dispatcher from some <tt class="docutils literal"><span class="pre">dispatcherURI_file</span></tt>. We then also need to
add an extra keyword argument to the constructor of the <tt class="xref py py-class docutils literal"><span class="pre">NestedSampling</span></tt> object:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="c">#construct the NestedSampling object and pass dispatcher URI</span>
<span class="n">ns</span> <span class="o">=</span> <span class="n">NestedSampling</span><span class="p">(</span><span class="n">replicas</span><span class="p">,</span> <span class="n">mc_runner</span><span class="p">,</span> <span class="n">stepsize</span><span class="o">=</span><span class="n">stepsize</span><span class="p">,</span> <span class="n">nproc</span><span class="o">=</span><span class="n">nproc</span><span class="p">,</span> <span class="n">dispatcher_URI</span><span class="o">=</span><span class="n">dispatcherURI</span><span class="p">,</span>
                    <span class="n">max_stepsize</span><span class="o">=</span><span class="mi">10</span><span class="p">)</span>
</pre></div>
</div>
<p>The actual example makes use of <tt class="docutils literal"><span class="pre">argparse</span></tt> and can be found in examples/run_hparticle_distributed.py.</p>
<div class="section" id="writing-a-nested-sampling-worker">
<h3>Writing a nested sampling worker<a class="headerlink" href="#writing-a-nested-sampling-worker" title="Permalink to this headline">¶</a></h3>
<p>First we import the modules that we need:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="kn">from</span> <span class="nn">nested_sampling</span> <span class="kn">import</span> <span class="n">pyro_worker</span>
<span class="kn">from</span> <span class="nn">nested_sampling</span> <span class="kn">import</span> <span class="n">MonteCarloWalker</span><span class="p">,</span> <span class="n">Harmonic</span>
</pre></div>
</div>
<p>We then construct the potential and the MOnte Carlo objects as above:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">nsteps</span> <span class="o">=</span> <span class="mf">1e3</span>    <span class="c">#no. of Monte Carlo steps per walk</span>
<span class="n">ndof</span> <span class="o">=</span> <span class="mi">3</span>        <span class="c">#no. of degrees of freedom</span>
<span class="n">potential</span> <span class="o">=</span> <span class="n">Harmonic</span><span class="p">(</span><span class="n">ndof</span><span class="p">)</span>
<span class="n">mc_runner</span> <span class="o">=</span> <span class="n">MonteCarloWalker</span><span class="p">(</span><span class="n">potential</span><span class="p">,</span> <span class="n">mciter</span><span class="o">=</span><span class="n">nsteps</span><span class="p">)</span>
</pre></div>
</div>
<p>and inizialise the Pyro worker:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">dispatcher_URI</span> <span class="o">=</span> <span class="s">&quot;PYRO:obj###@17###0:3###8&quot;</span> <span class="c">#address of the dispatcher</span>
<span class="n">worker_name</span> <span class="o">=</span> <span class="bp">None</span>                          <span class="c">#name of worker, when None it&#39;s chosen automatically</span>
<span class="n">host</span> <span class="o">=</span> <span class="bp">None</span>                                 <span class="c">#host name, when None found automatically</span>
<span class="n">port</span> <span class="o">=</span> <span class="mi">0</span>                                    <span class="c">#port number</span>
<span class="n">server_type</span> <span class="o">=</span> <span class="s">&quot;multiplex&quot;</span>                   <span class="c">#type of server</span>

<span class="n">worker</span> <span class="o">=</span> <span class="n">pyro_worker</span><span class="p">(</span><span class="n">dispatcher_URI</span><span class="p">,</span> <span class="n">mc_runner</span><span class="p">,</span> <span class="n">worker_name</span><span class="o">=</span><span class="n">worker_name</span><span class="p">,</span> <span class="n">host</span><span class="o">=</span><span class="n">host</span><span class="p">,</span> <span class="n">port</span><span class="o">=</span><span class="n">port</span><span class="p">,</span> <span class="n">server_type</span><span class="o">=</span><span class="n">server_type</span><span class="p">)</span>
<span class="n">worker</span><span class="o">.</span><span class="n">_start_worker</span><span class="p">()</span>
</pre></div>
</div>
<p>In the actual example we use the <tt class="docutils literal"><span class="pre">argparse</span></tt> package to launch the worker from the command line. In practice the user
only needs to replace the potential and the Monte Carlo runner to fit his needs.</p>
</div>
<div class="section" id="running-distributed-nested-sampling">
<h3>Running distributed nested sampling<a class="headerlink" href="#running-distributed-nested-sampling" title="Permalink to this headline">¶</a></h3>
<p>We start by initialising a dispatcher by running:</p>
<div class="highlight-python"><pre>$python scripts/start_dispatcher.py</pre>
</div>
<p>which will choose a random <tt class="docutils literal"><span class="pre">dispatcher_URI</span></tt> and default <tt class="docutils literal"><span class="pre">port</span></tt> from where it will listen for incoming
communications. One can alternatively specify the server name, the host address, the port number and
the server type (multiplex or threaded), we use the multiplex server by default. From the Pyro4
documentation we note that</p>
<p><em>&#8220;a connected proxy that is unused takes up resources on the server. In the case of the threadpool server type, it locks
up a single thread. If you have too many connected proxies at the same time, the server may run out
of threads and stops responding. (The multiplex server doesn’t have this particular issue).&#8221;</em></p>
<p>The dispatcher will also print its URI to a default file name <tt class="docutils literal"><span class="pre">dispatcher_uri.dat</span></tt> from where we can
read the address of URI (as well as printing it on the termianl). Let us assume that the randomly
allocated dispatcher URI is:</p>
<div class="highlight-python"><pre>$PYRO:obj_fbe65d26b5ed49d7bf3a590bea419a63@888.88.888.888:77777</pre>
</div>
<p>we can then start a worker by doing:</p>
<div class="highlight-python"><pre>$python scripts/start_worker.py 3 PYRO:obj_fbe65d26b5ed49d7bf3a590bea419a63@888.88.888.888:77777 -n 1000</pre>
</div>
<p>where the first positional argument is <tt class="docutils literal"><span class="pre">ndof</span></tt>, the second positional argument is the dispatcher URI and the optional
argument <tt class="docutils literal"><span class="pre">-n</span> <span class="pre">1000</span></tt> is the number of Monte Carlo steps to perform at each call. We can start as many workers as we like,
although we expect that the dispatcher efficiency decreases as the number of workers increases.</p>
<p>Finally we need to run the terminal command-line:</p>
<div class="highlight-python"><pre>$python examples/harmonic/run_hparticle_distributed.py --dispatcherURI --nreplicas 1e3 --ndof 3 --nprocs 4 --nsteps 1e3 --stepsize 0.1 --etol 0.01</pre>
</div>
<p>assuming that the dispatcher was started in the same location. Alternatively we can pass
the path to the <em>dispatcherURI_file</em> using the <tt class="docutils literal"><span class="pre">--dispatcherURI-file</span></tt> option. Note that <tt class="docutils literal"><span class="pre">--nprocs</span></tt> should
match the nummber of workers for best efficiency.</p>
</div>
</div>
</div>


          </div>
        </div>
      </div>
      <div class="sphinxsidebar">
        <div class="sphinxsidebarwrapper">
  <h3><a href="index.html">Table Of Contents</a></h3>
  <ul>
<li><a class="reference internal" href="#">Getting started</a><ul>
<li><a class="reference internal" href="#basic-elements">Basic elements</a></li>
<li><a class="reference internal" href="#writing-a-nested-sampling-runner">Writing a nested sampling runner</a><ul>
<li><a class="reference internal" href="#running-nested-sampling-on-a-single-node">Running nested sampling on a single node</a></li>
</ul>
</li>
<li><a class="reference internal" href="#writing-a-nested-sampling-runner-for-distributed-computing">Writing a nested sampling runner for distributed computing</a><ul>
<li><a class="reference internal" href="#writing-a-nested-sampling-worker">Writing a nested sampling worker</a></li>
<li><a class="reference internal" href="#running-distributed-nested-sampling">Running distributed nested sampling</a></li>
</ul>
</li>
</ul>
</li>
</ul>

  <h4>Previous topic</h4>
  <p class="topless"><a href="index.html"
                        title="previous chapter">nested sampling : the Python parallel nested sampling algorithm</a></p>
  <h4>Next topic</h4>
  <p class="topless"><a href="NestedSampling.html"
                        title="next chapter">Nested Sampling</a></p>
<div id="searchbox" style="display: none">
  <h3>Quick search</h3>
    <form class="search" action="search.html" method="get">
      <input type="text" name="q" />
      <input type="submit" value="Go" />
      <input type="hidden" name="check_keywords" value="yes" />
      <input type="hidden" name="area" value="default" />
    </form>
    <p class="searchtip" style="font-size: 90%">
    Enter search terms or a module, class or function name.
    </p>
</div>
<script type="text/javascript">$('#searchbox').show(0);</script>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="related">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="genindex.html" title="General Index"
             >index</a></li>
        <li class="right" >
          <a href="py-modindex.html" title="Python Module Index"
             >modules</a> |</li>
        <li class="right" >
          <a href="NestedSampling.html" title="Nested Sampling"
             >next</a> |</li>
        <li class="right" >
          <a href="index.html" title="nested sampling : the Python parallel nested sampling algorithm"
             >previous</a> |</li>
        <li><a href="index.html">nested sampling 1.0.0 documentation</a> &raquo;</li> 
      </ul>
    </div>
    <div class="footer">
        &copy; Copyright 2014, Stefano Martiniani and Jacob D. Stevenson.
      Created using <a href="http://sphinx.pocoo.org/">Sphinx</a> 1.1.3.
    </div>
  </body>
</html>